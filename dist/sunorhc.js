/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["Sunorhc"] = factory();
	else
		root["Sunorhc"] = factory();
})(this, function() {
return /******/ (function() { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./src/defaults.js":
/*!*************************!*\
  !*** ./src/defaults.js ***!
  \*************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\n  /**\r\n   * Sunorhc.js - Library for JavaScript to handle the datetime with the Epoch time conversion method starting\r\n   *              from the CE of the Gregorian calendar.\r\n   * @package sunorhc\r\n   */\n  version: '1.0.0',\n\n  /**\r\n   * Default TimeZone\r\n   *\r\n   * @type {string} - Either \"UTC\" or \"local\" only\r\n   */\n  timezone: 'UTC',\n\n  /**\r\n   * TZ database name\r\n   *\r\n   * @type {string}\r\n   */\n  tzName: '',\n\n  /**\r\n   * The identification unit of the first numeric argument given to the constructor\r\n   *\r\n   * @type {string} - Either \"year\" or \"epoch\" only\r\n   */\n  firstArgument: 'year',\n\n  /**\r\n   * The locale used instead of browser system locale when retrieve locale date/time string\r\n   *\r\n   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl/Locale/Locale\r\n   * @type {string} - Depend on the Intl.Locale constructor that is a standard built-in property\r\n   */\n  locale: 'en-US',\n\n  /**\r\n   * Unit for retrieving epoch times\r\n   *\r\n   * @type {string} - Either seconds or milliseconds is allowed at unit\r\n   */\n  epochUnit: 'second',\n\n  /**\r\n   * Options for the `Date.prototype.toLocaleDateString()` method\r\n   *\r\n   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/toLocaleDateString\r\n   * @typedef {object} LocaleFormats\r\n   * @property {string|object} common\r\n   * @property {string|object} year\r\n   * @property {string|object} month\r\n   * @property {string|object} day\r\n   * @property {string|object} weekday\r\n   * @property {string|object} hour\r\n   * @property {string|object} minute\r\n   * @property {string|object} second\r\n   * @property {string|object} era\r\n   */\n  localeFormats: {\n    common: {\n      hour12: false\n      /* calender: 'iso8601', */\n\n    },\n    year: {\n      year: 'numeric'\n    },\n    month: {\n      month: 'numeric'\n    },\n    day: {\n      day: 'numeric'\n    },\n    weekday: {\n      weekday: 'long'\n    },\n    hour: {\n      hour: 'numeric'\n    },\n    minute: {\n      minute: '2-digit'\n    },\n    second: {\n      second: '2-digit'\n    },\n    era: {\n      era: 'long'\n    }\n  },\n\n  /**\r\n   * Whether outputting verbose of Sunorhc behavior into browser console.\r\n   * This option will be useful for debug.\r\n   *\r\n   * @type {boolean} - If false, it prevent to output the console[error, warn] too.\r\n   */\n  verbose: false\n});\n\n//# sourceURL=webpack://Sunorhc/./src/defaults.js?");

/***/ }),

/***/ "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ Sunorhc; }\n/* harmony export */ });\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils */ \"./src/utils.js\");\n/* harmony import */ var _defaults__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./defaults */ \"./src/defaults.js\");\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\n\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== \"undefined\" && arr[Symbol.iterator] || arr[\"@@iterator\"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }\n\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _iterableToArray(iter) { if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter); }\n\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _construct(Parent, args, Class) { if (_isNativeReflectConstruct()) { _construct = Reflect.construct; } else { _construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) _setPrototypeOf(instance, Class.prototype); return instance; }; } return _construct.apply(null, arguments); }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\n\n\nvar REGEX_PARSE = /^(\\d{4})[-/]?(\\d{1,2})?[-/]?(\\d{0,2})[Tt\\s]*(\\d{1,2})?:?(\\d{1,2})?:?(\\d{1,2})?[.:]?(\\d+)?$/;\nvar REGEX_UNITS = /^((year|month|week|day|hour|minute|second|millisecond)s?|min|sec|ms)$/i;\nvar REGEX_TZNAME = /^(A(frica|merica|ntarctica|sia|tlantic|ustralia)|Europe|Indian|Pacific|Etc|GMT|UTC|local)(\\/[A-Z][a-zA-Z0-9_-]*)?$/;\nvar INVALID_DATE = 'Invalid Date';\nvar MS_A_SECOND = 1000;\nvar MS_A_MINUTE = MS_A_SECOND * 60;\nvar MS_A_HOUR = MS_A_MINUTE * 60;\nvar MS_A_DAY = MS_A_HOUR * 24;\nvar MS_A_WEEK = MS_A_DAY * 7;\nvar MIN_MONTH_DAYS = 28;\nvar AVG_MONTH_DAYS = Math.round((365 + 366) / 24 * 1000) / 1000;\nvar MIN_YEAR_DAYS = 365;\nvar AVG_YEAR_DAYS = (365 * 3 + 366) / 4;\nvar CE_EPOCH_UNIX = -62135596800000; // Elapsed times of CE epoch in UNIX time (= milliseconds difference between UNIX epoch and CE epoch)\n\nvar BI = function BI(value) {\n  return __webpack_require__.g.BigInt(value);\n};\n\nvar wrapper = function wrapper() {\n  try {\n    for (var _len = arguments.length, payloads = new Array(_len), _key = 0; _key < _len; _key++) {\n      payloads[_key] = arguments[_key];\n    }\n\n    return _construct(Sunorhc, payloads);\n  } catch (e) {\n    return INVALID_DATE;\n  }\n};\n\nvar Sunorhc = /*#__PURE__*/function () {\n  /**\r\n   * Construct Sunorhc\r\n   *\r\n   * @public\r\n   * @param {?(number|string|object)} year|date - valid 1st argument as payloads\r\n   * @param {?number} month                     - valid 2nd argument as payloads (allowed numeric are 1~12)\r\n   * @param {?number} day                       - valid 3rd argument as payloads\r\n   * @param {?number} hour                      - valid 4th argument as payloads\r\n   * @param {?number} minute                    - valid 5th argument as payloads\r\n   * @param {?number} second                    - valid 6th argument as payloads\r\n   * @param {?number} millisecond               - valid 7th argument as payloads (allowed numeric are 0~999)\r\n   * @param {?(string|object)} timezone|options [timezone=UTC] - last argument as payloads\r\n   */\n  function Sunorhc() {\n    _classCallCheck(this, Sunorhc);\n\n    // Initialize plugin configuration\n    this.config = _utils__WEBPACK_IMPORTED_MODULE_0__.default.deepMerge({}, _defaults__WEBPACK_IMPORTED_MODULE_1__.default);\n\n    for (var _len2 = arguments.length, payloads = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n      payloads[_key2] = arguments[_key2];\n    }\n\n    return this._init(payloads);\n  }\n  /**\r\n   * Parse payloads\r\n   *\r\n   * @private\r\n   * @param {array} payloads\r\n   */\n\n\n  _createClass(Sunorhc, [{\n    key: \"_parse\",\n    value: function _parse(payloads) {\n      var _this = this;\n\n      var keys = ['$y', '$m', '$d', '$h', '$mi', '$s', '$ms'],\n          _now = new Date(); // today\n\n\n      var _argsIsUTC = true,\n          _fromLocalPayloads = true,\n          _isParseStr = false; //this.config.offset = _now.getTimezoneOffset() * 60000// Provisional definition (an unit is milliseconds)\n\n      this.config.dateArgs = {\n        $y: _now.getUTCFullYear(),\n        $m: _now.getUTCMonth(),\n        $d: _now.getUTCDate(),\n        $h: _now.getUTCHours(),\n        $mi: _now.getUTCMinutes(),\n        $s: _now.getUTCSeconds(),\n        $ms: _now.getUTCMilliseconds()\n      }; // parse payloads\n\n      if (Array.isArray(payloads) && payloads.length > 0) {\n        // If the constructor has more than one argument\n        if (typeof payloads[0] !== 'number') {\n          if (payloads[0] instanceof Date) {\n            // When the first argument is an instance of the Date object\n            var _dt = new Date(payloads[0]);\n\n            this.config.dateArgs = {\n              $y: _dt.getUTCFullYear(),\n              $m: _dt.getUTCMonth(),\n              $d: _dt.getUTCDate(),\n              $h: _dt.getUTCHours(),\n              $mi: _dt.getUTCMinutes(),\n              $s: _dt.getUTCSeconds(),\n              $ms: _dt.getUTCMilliseconds()\n            };\n            payloads.shift();\n          } else if (typeof payloads[0] === 'string') {\n            var _fa = payloads[0].trim().replace(/['\"]/g, '');\n\n            if (/^(-|\\+)?[0-9]{1,}$/i.test(_fa)) {\n              // When the first argument is a numeric string\n              payloads[0] = parseInt(_fa, 10);\n            } else {\n              // When the first argument is a string as kind of the date\n              var d = _fa.match(REGEX_PARSE);\n\n              if (d) {\n                // When the recommended datetime format\n                this.config.dateArgs = {\n                  $y: d[1],\n                  $m: typeof d[2] === 'undefined' ? 0 : d[2] - 1,\n                  $d: typeof d[3] === 'undefined' ? 1 : d[3],\n                  $h: typeof d[4] === 'undefined' ? 0 : d[4],\n                  $mi: typeof d[5] === 'undefined' ? 0 : d[5],\n                  $s: typeof d[6] === 'undefined' ? 0 : d[6],\n                  $ms: typeof d[7] === 'undefined' ? 0 : parseInt(d[7].substring(0, 3), 10)\n                };\n                _fromLocalPayloads = !/Z$/i.test(d[0]);\n                _isParseStr = true;\n                payloads.shift();\n              } else if (!_fa.match(REGEX_TZNAME)) {\n                // When an ambiguous string is given as the datetime\n                var _preDt = new Date(_fa);\n\n                if (this.isValid(_preDt)) {\n                  this.config.dateArgs = {\n                    $y: _preDt.getUTCFullYear(),\n                    $m: _preDt.getUTCMonth(),\n                    $d: _preDt.getUTCDate(),\n                    $h: _preDt.getUTCHours(),\n                    $mi: _preDt.getUTCMinutes(),\n                    $s: _preDt.getUTCSeconds(),\n                    $ms: _preDt.getUTCMilliseconds()\n                  };\n                  _isParseStr = true;\n                  payloads.shift();\n                }\n              }\n            }\n          }\n        }\n\n        var lastElm = payloads.splice(-1, 1)[0];\n\n        if (typeof lastElm === 'number') {\n          // If the trailing argument is a number, do nothing.\n          payloads.push(lastElm);\n        } else if (typeof lastElm === 'string') {\n          // If the last argument is a string, set the timezone after checking value.\n          lastElm = lastElm.trim().replace(/['\"]/g, '');\n\n          if (/^-?\\d{1,}$/i.test(lastElm)) {\n            // If the trailing argument is a number, do nothing.\n            payloads.push(parseInt(lastElm, 10));\n          } else if (/^(utc|local)$/i.test(lastElm)) {\n            // Set the timezone of \"UTC\" or \"local\"\n            this.config.timezone = /^utc$/i.test(lastElm) ? 'UTC' : 'local';\n            _argsIsUTC = this.config.timezone === 'UTC';\n          } else {\n            // Set the \"local\" timezone with timezone name\n            if (lastElm.match(REGEX_TZNAME)) {\n              this.config.timezone = 'local';\n              this.config.tzName = lastElm;\n            } else {\n              this._logger(\"An invalid timezone name was given: \\\"\".concat(lastElm, \"\\\"\"), 2);\n\n              this.config.timezone = 'UTC';\n            }\n\n            _argsIsUTC = this.config.timezone === 'UTC';\n          }\n        } else if (_utils__WEBPACK_IMPORTED_MODULE_0__.default.isObject(lastElm)) {\n          // If the last argument is an object, it will override the Sunorhc configration.\n          if (_utils__WEBPACK_IMPORTED_MODULE_0__.default.hasKey(lastElm, 'version')) {\n            delete lastElm.version;\n          }\n\n          if (_utils__WEBPACK_IMPORTED_MODULE_0__.default.hasKey(lastElm, 'offset')) {\n            delete lastElm.offset;\n          }\n\n          if (_utils__WEBPACK_IMPORTED_MODULE_0__.default.hasKey(lastElm, 'dateArgs')) {\n            delete lastElm.dateArgs;\n          }\n\n          this.config = _utils__WEBPACK_IMPORTED_MODULE_0__.default.mergeOptions(this.config, lastElm);\n        } else {\n          // If the last argument is an invalid value.\n          if (typeof lastElm !== 'undefined' && _utils__WEBPACK_IMPORTED_MODULE_0__.default.hasKey(this.config, 'dateArgs')) {\n            delete this.config.dateArgs;\n\n            this._logger('The argument contains an invalid value.', 2);\n          }\n        }\n\n        if (payloads.length > 0) {\n          if (/^(timestamp|unix|ce(|epoch))$/i.test(this.config.firstArgument) && typeof payloads[0] === 'number') {\n            // When the first argument for constructor is interpreted as the elapsed times from the epoch time.\n            var _edt = null;\n\n            if (/^(timestamp|unix)$/i.test(this.config.firstArgument)) {\n              _edt = new Date(payloads[0]);\n            } else {\n              _edt = new Date(CE_EPOCH_UNIX + payloads[0]);\n            }\n\n            this.config.dateArgs = {\n              $y: _edt.getUTCFullYear(),\n              $m: _edt.getUTCMonth(),\n              $d: _edt.getUTCDate(),\n              $h: _edt.getUTCHours(),\n              $mi: _edt.getUTCMinutes(),\n              $s: _edt.getUTCSeconds(),\n              $ms: _edt.getUTCMilliseconds()\n            };\n            _argsIsUTC = this.config.timezone === 'UTC';\n          } else {\n            // When the first argument for constructor is interpreted as the numeric year (for defaults).\n            var _y = typeof payloads[0] === 'number' ? payloads[0] : parseInt(payloads[0].toString(), 10);\n\n            if (!isNaN(_y)) {\n              this.config.dateArgs = {\n                $y: _y,\n                $m: typeof payloads[1] === 'undefined' ? 0 : parseInt(payloads[1], 10) - 1,\n                $d: typeof payloads[2] === 'undefined' ? 1 : parseInt(payloads[2], 10),\n                $h: typeof payloads[3] === 'undefined' ? 0 : parseInt(payloads[3], 10),\n                $mi: typeof payloads[4] === 'undefined' ? 0 : parseInt(payloads[4], 10),\n                $s: typeof payloads[5] === 'undefined' ? 0 : parseInt(payloads[5], 10),\n                $ms: typeof payloads[6] === 'undefined' ? 0 : payloads[6]\n              };\n              _argsIsUTC = false;\n              _fromLocalPayloads = false;\n            }\n          }\n        }\n      } else {// If the constructor has no arguments\n      }\n\n      if (!_utils__WEBPACK_IMPORTED_MODULE_0__.default.hasKey(this.config, 'dateArgs')) {\n        throw '[Sunorhc] Failed to set options for initializing object.';\n      } // Set the primitive datetime as \"_baseDate\"\n\n\n      var _utcDt = new Date(Date.UTC.apply(Date, _toConsumableArray(keys.map(function (v) {\n        return _this.config.dateArgs[v];\n      })))),\n          _zonedDt = _construct(Date, _toConsumableArray(keys.map(function (v) {\n        return _this.config.dateArgs[v];\n      })));\n\n      if (this.config.dateArgs.$y < 100) {\n        _utcDt = new Date(_utcDt.setUTCFullYear(this.config.dateArgs.$y));\n        _zonedDt = new Date(_zonedDt.setFullYear(this.config.dateArgs.$y));\n      }\n\n      if (_isParseStr) {\n        if (_argsIsUTC) {\n          this.config.offset = 0;\n          this.config.timezone = 'UTC';\n          this._baseDate = _utcDt;\n        } else {\n          this.config.offset = _zonedDt.getTimezoneOffset() * 60000;\n          this.config.timezone = 'local';\n          this._baseDate = new Date(_zonedDt.getTime() - this.config.offset);\n        }\n      } else {\n        if (!_argsIsUTC) {\n          this.config.offset = _zonedDt.getTimezoneOffset() * 60000;\n          _zonedDt = _fromLocalPayloads ? new Date(_utcDt.getTime() - this.config.offset) : new Date(_utcDt.getTime());\n        } else {\n          this.config.offset = 0;\n          _zonedDt = new Date(_utcDt.getTime());\n        }\n\n        if (this.config.timezone === 'UTC') {\n          this._baseDate = this.isValid(_utcDt) ? _utcDt : INVALID_DATE;\n          this.config.offset = 0;\n        } else {\n          this._baseDate = this.isValid(_zonedDt) ? _zonedDt : INVALID_DATE;\n\n          if (!this.hasDST() && this.config.offset == 0) {\n            this._baseDate = this.isValid(_utcDt) ? _utcDt : INVALID_DATE;\n            this.config.timezone = 'UTC';\n          }\n        }\n      }\n    }\n    /**\r\n     * Initialize instance\r\n     *\r\n     * @private\r\n     */\n\n  }, {\n    key: \"_init\",\n    value: function _init(payloads) {\n      // Parse payloads\n      this._parse(payloads);\n\n      var _locale = 'en-US';\n      this._i = this.isValid() ? Object.assign({}, {\n        $Y: parseInt(this.getLDE('year', 'numeric', _locale), 10),\n        $MON: parseInt(this.getLDE('month', 'numeric', _locale), 10),\n        $MONL: this.getLDE('month', 'long', _locale),\n        $MONS: this.getLDE('month', 'short', _locale),\n        $W: this.getWeekOfYear(),\n        $D: parseInt(this.getLDE('day', 'numeric', _locale), 10),\n        $WD: this.getWeekdayIndex('iso8601'),\n        $WDL: this.getLDE('weekday', 'long', _locale),\n        $WDS: this.getLDE('weekday', 'short', _locale),\n        $O: this.getCumulativeDays(),\n        $H: parseInt(this.getLDE('hour', {\n          hour12: false,\n          hour: 'numeric'\n        }, _locale), 10),\n        $M: parseInt(this.getLDE('minute', 'numeric', _locale), 10),\n        $S: parseInt(this.getLDE('second', 'numeric', _locale), 10),\n        $MS: this.config.timezone === 'UTC' ? this._baseDate.getUTCMilliseconds() : this._baseDate.getMilliseconds(),\n        $TZ: this.config.timezone || 'UTC',\n        $TZO: this.config.timezone === 'UTC' ? 0 : this.getTZOffset(),\n        $TZOL: this.getTZOffset('hhmm'),\n        $TZOF: this.getTZOffset('full'),\n        $U: this.getUnixTime('s'),\n        $UMS: this.getUnixTime('ms'),\n        $E: this.getLDE('era', 'long', _locale),\n        $CE: this.getCEEpoch('s'),\n        $CEMS: this.getCEEpoch('ms'),\n        $DST: this.isDST(),\n        $DSTO: this.getDSTOffset()\n      }) : null; //delete this.config.dateArgs\n\n      Object.freeze(this.config);\n      Object.freeze(this._cache);\n      return this;\n    }\n    /**\r\n     * Logger\r\n     *\r\n     * @private\r\n     * @param {string} msg - output message\r\n     * @param {?number} type [type=0] - output type as console method\r\n     */\n\n  }, {\n    key: \"_logger\",\n    value: function _logger(msg) {\n      var type = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n\n      if (this.config.verbose) {\n        var types = ['log', 'info', 'warn', 'error', 'debug'];\n        console[types[type]](\"[Sunorhc] \".concat(msg));\n      }\n    } // Public methods\n\n    /**\r\n     * Calculate the UNIX Time (UTC) for this date.\r\n     *\r\n     * @public\r\n     * @param {?string} unit [unit=ms] - `s` as second or `ms` as millisecond\r\n     */\n\n  }, {\n    key: \"getUnixTime\",\n    value: function getUnixTime() {\n      var unit = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'ms';\n\n      if (!unit) {\n        unit = /^sec(|onds?)$/i.test(this.config.epochUnit) ? 's' : 'ms';\n      }\n\n      var _time = 0;\n\n      if (this.config.timezone === 'UTC') {\n        _time = this._baseDate.getTime();\n      } else {\n        var _da = this.config.dateArgs;\n        _time = new Date(_da.$y, _da.$m, _da.$d, _da.$h, _da.$mi, _da.$s, _da.$ms).getTime();\n      }\n\n      return Math.floor(_time / (unit === 's' ? 1000 : 1));\n    }\n    /**\r\n     * Calculate the times (UTC) epoched from the first datetime on Common Era of this date.\r\n     *\r\n     * @public\r\n     * @param {?string} unit [unit=ms] - `s` as second or `ms` as millisecond\r\n     */\n\n  }, {\n    key: \"getCEEpoch\",\n    value: function getCEEpoch() {\n      var unit = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'ms';\n\n      if (!unit) {\n        unit = /^sec(|onds?)$/i.test(this.config.epochUnit) ? 's' : 'ms';\n      }\n\n      var _ut = this.getUnixTime();\n\n      return Math.floor((_ut + Math.abs(CE_EPOCH_UNIX)) / (unit === 's' ? 1000 : 1));\n    }\n    /**\r\n     * Returns a string with a language sensitive representation of the date portion of this date \r\n     * that depending on toLocaleDateString or toLocaleTimeString method.\r\n     *\r\n     * @public\r\n     * @param {string} elementName\r\n     * @param {?(string|object)} format\r\n     * @param {?string} locale\r\n     * @param {?string} timezone [timezone=UTC]\r\n     */\n\n  }, {\n    key: \"getLocaleDateElement\",\n    value: function getLocaleDateElement(elementName) {\n      var format = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n      var locale = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n      var timezone = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 'UTC';\n\n      if (!locale) {\n        locale = this.config.locale;\n      }\n\n      var options = _utils__WEBPACK_IMPORTED_MODULE_0__.default.deepMerge(_utils__WEBPACK_IMPORTED_MODULE_0__.default.isObject(this.config.localeFormats.common) ? this.config.localeFormats.common : {}, {\n        locales: locale\n      });\n\n      if (!format) {\n        if (_utils__WEBPACK_IMPORTED_MODULE_0__.default.hasKey(this.config.localeFormats, elementName)) {\n          options = _utils__WEBPACK_IMPORTED_MODULE_0__.default.deepMerge(options, _utils__WEBPACK_IMPORTED_MODULE_0__.default.isObject(this.config.localeFormats[elementName]) ? this.config.localeFormats[elementName] : _defineProperty({}, elementName, this.config.localeFormats[elementName]));\n        }\n      } else if (typeof format === 'string') {\n        options[elementName] = format;\n      } else if (_utils__WEBPACK_IMPORTED_MODULE_0__.default.isObject(format)) {\n        options = _utils__WEBPACK_IMPORTED_MODULE_0__.default.deepMerge(options, format);\n      }\n\n      if (REGEX_TZNAME.test(timezone)) {\n        options.timeZone = timezone;\n      } else {//\n      }\n\n      var _tmp, _y, retval;\n\n      switch (elementName) {\n        case 'year':\n          _tmp = _utils__WEBPACK_IMPORTED_MODULE_0__.default.deepMerge({}, options);\n\n          if (options.year === '4-digit') {\n            _tmp.year = 'numeric';\n          }\n\n          retval = parseInt(this._baseDate.toLocaleDateString(locale, _tmp), 10);\n          _y = this._baseDate.getUTCFullYear();\n\n          if (_y < 0) {\n            retval = (retval - 1) * -1;\n          } else if (_y == 0) {\n            retval = retval - 1;\n          }\n\n          break;\n\n        case 'month':\n        case 'day':\n        case 'weekday':\n        case 'era':\n          retval = this._baseDate.toLocaleDateString(locale, options);\n          break;\n\n        case 'hour':\n          retval = this._baseDate.toLocaleTimeString(locale, options);\n\n          if (_utils__WEBPACK_IMPORTED_MODULE_0__.default.hasKey(options, 'hour12')) {\n            retval = options.hour12 ? retval : retval == 24 ? 0 : retval;\n          } else if (_utils__WEBPACK_IMPORTED_MODULE_0__.default.hasKey(options, 'hourCycle')) {\n            /* \"hour12\" takes precedence, so \"hourCycle\" is disabled.\r\n            switch (options.hourCycle) {\r\n                case 'h11':\r\n                case 'h12':\r\n                case 'h23':\r\n                case 'h24':\r\n                    break\r\n            } */\n          }\n\n          if (/^(numeric|2-digit)$/.test(options.hour)) {\n            retval = parseInt(retval, 10);\n          } else {\n            var _m = retval.match(/^(\\d{2}):\\d{2}:\\d{2}(.*)$/);\n\n            if (_m) {\n              retval = \"\".concat(_m[1]).concat(_m[2]);\n            }\n          }\n\n          break;\n\n        case 'minute':\n        case 'second':\n          retval = this._baseDate.toLocaleTimeString(locale, options);\n          break;\n\n        case 'week':\n          retval = this._i.$W;\n          break;\n\n        case 'millisecond':\n          retval = this._i.$MS;\n          break;\n\n        default:\n          retval = null;\n          break;\n      } // Filtering\n\n\n      retval = retval.toString();\n\n      if (options[elementName] === '2-digit') {\n        _tmp = parseInt(retval, 10);\n        return Math.abs(_tmp).toString().length < 2 ? (_tmp < 0 ? '-' : '') + Math.abs(_tmp).toString().padStart(2, '0') : retval;\n      } else if (elementName === 'year' && options[elementName] === '4-digit') {\n        _tmp = parseInt(retval, 10);\n        return Math.abs(_tmp).toString().length < 4 ? (_tmp < 0 ? '-' : '') + Math.abs(_tmp).toString().padStart(4, '0') : retval;\n      } else if (elementName === 'millisecond' && options[elementName] === 'zerofill') {\n        return retval.length == 3 ? retval : retval.padStart(3, '0');\n      } else {\n        return !isNaN(retval) ? parseInt(retval.toString(), 10) : retval;\n      }\n    }\n    /**\r\n     * Alias as shorthand of \"getLocaleDateElement\" method.\r\n     *\r\n     * @public\r\n     */\n\n  }, {\n    key: \"getLDE\",\n    value: function getLDE(elementName) {\n      var format = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n      var locale = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n      var timezone = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 'UTC';\n      return this.getLocaleDateElement(elementName, format, locale, timezone);\n    }\n    /**\r\n     * Returns the instantiated date in a formatted format by PHP's date_format()-like formatter.\r\n     *\r\n     * @public\r\n     * @param {string}  formatter\r\n     * @param {?string} locale\r\n     * @param {?object} replacer - A replacer object can be specified to further replace the formatted string.\r\n     *                             The key and value become the 1st and 2nd arguments of `replace()` function. \r\n     */\n\n  }, {\n    key: \"format\",\n    value: function format(formatter) {\n      var locale = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n      var replacer = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n\n      if (!locale) {\n        locale = this.config.locale;\n      } else if (_typeof(locale) === 'object' && !replacer) {\n        replacer = locale;\n        locale = this.config.locale;\n      } // Alphabet reserved as matcher identifier:\n      //     \"B\",\"C\",\"D\",    \"F\",\"G\",\"H\",\"I\",    \"L\",\"M\",\"N\",    \"S\",    \"U\",\"V\",\"W\",\"Y\",\"Z\",\n      // \"a\",\"b\",\"c\",\"d\",\"e\",\"f\",\"g\",\"h\",\"i\",\"j\",\"l\",\"m\",\"n\",\"r\",\"s\",\"t\",\"u\",\"v\",\"w\",\"y\",\"z\" \n\n\n      var matcher = {\n        // Year\n        Y: this._i.$Y,\n        // = this.getLDE('year', 'numeric', locale)\n        y: this.getLDE('year', '2-digit', locale),\n        f: this.getLDE('year', '4-digit', locale),\n        L: this.getDaysInYear() == 366 ? 1 : 0,\n        // Month\n        F: this.getLDE('month', 'long', locale),\n        m: this._i.$MON.toString().padStart(2, '0'),\n        // = this.getLDE('month', '2-digit', locale)\n        M: this.getLDE('month', 'short', locale),\n        n: this._i.$MON,\n        // = this.getLDE('month', 'numeric', locale)\n        t: this.getDaysInMonth(),\n        // Week\n        W: this._i.$W,\n        // = this.getWeekOfYear()\n        // Day\n        d: this._i.$D.toString().padStart(2, '0'),\n        // = this.getLDE('day', '2-digit', locale)\n        j: this._i.$D,\n        // = this.getLDE('day', 'numeric', locale)\n        z: this._i.$O,\n        // = this.getCumulativeDays()\n        // Weekday\n        l: this.getLDE('weekday', 'long', locale),\n        D: this.getLDE('weekday', 'short', locale),\n        //N: [7, 1, 2, 3, 4, 5, 6][(this._i.timezone === 'UTC' ? this._baseDate.getUTCDay() : this._baseDate.getDay())],// ISO-8601 format numeric weekday: 1 (Monday) - 7 (Sunday)\n        N: this._i.$WD,\n        // = this.getWeekdayIndex('iso8601')\n        //w: this._i.timezone === 'UTC' ? this._baseDate.getUTCDay() : this._baseDate.getDay(),// numeric weekday: 0 (Sunday) - 6 (Saturday)\n        w: this.getWeekdayIndex(),\n        // Hour\n        a: this.getLDE('hour', {\n          hour12: false,\n          hour: 'numeric'\n        }, locale) > 12 ? 1 : 0,\n        // in morning:0 or afternoon:1\n        g: parseInt(this.getLDE('hour', {\n          hour12: true,\n          hour: 'numeric'\n        }, 'en-US'), 10),\n        G: this._i.$H,\n        // = this.getLDE('hour', {hour12: false, hour: 'numeric'}, locale)\n        h: parseInt(this.getLDE('hour', {\n          hour12: true,\n          hour: '2-digit'\n        }, 'en-US'), 10).toString().padStart(2, '0'),\n        H: this._i.$H.toString().padStart(2, '0'),\n        // = this.getLDE('hour', {hour12: false, hour: '2-digit'}, locale)\n        // Minute\n        C: this._i.$M,\n        // = this.getLDE('minute', 'numeric', locale)\n        i: this._i.$M.toString().padStart(2, '0'),\n        // = this.getLDE('minute', '2-digit', locale)\n        // Second\n        S: this._i.$S,\n        // = this.getLDE('second', 'numeric', locale)\n        s: this._i.$S.toString().padStart(2, '0'),\n        // = this.getLDE('second', '2-digit', locale)\n        // Millisecond\n        V: this._i.$MS,\n        // = this.getLDE('millisecond')\n        v: this._i.$MS.toString().padStart(3, '0'),\n        // = this.getLDE('millisecond', 'zerofill')\n        // TimeZone\n        e: this.timezone,\n        // = this._i.$TZ,\n        Z: this._i.$TZ === 'UTC' ? 0 : this.getTZOffset('s'),\n        I: this.isDST() ? 1 : 0,\n        // Full Datetime\n        c: this.getISO(),\n        r: this.getRFC(2822),\n        // RFC 2822 format date\n        U: this.getUnixTime('s'),\n        u: this.getUnixTime('ms'),\n        B: this.getCEEpoch('s'),\n        b: this.getCEEpoch('ms')\n      };\n\n      var retval = _toConsumableArray(formatter).reduce(function (acc, cur, idx, src) {\n        if (Object.keys(matcher).includes(cur)) {\n          acc += matcher[cur];\n        } else if (/\\\\/.test(cur)) {\n          acc += src[idx + 1];\n          delete src[idx + 1];\n        } else {\n          acc += cur;\n        }\n\n        return acc;\n      }, '');\n\n      if (replacer) {\n        var REGEX_STR = /^\\/(.*)\\/([gsdimyu]*)?$/;\n\n        for (var _i2 = 0, _Object$entries = Object.entries(replacer); _i2 < _Object$entries.length; _i2++) {\n          var _Object$entries$_i = _slicedToArray(_Object$entries[_i2], 2),\n              key = _Object$entries$_i[0],\n              val = _Object$entries$_i[1];\n\n          if (key && typeof key === 'string') {\n            var _m = key.match(REGEX_STR),\n                re = null;\n\n            if (_m) {\n              if (_m.length > 2) {\n                re = new RegExp(_m[1], _m[2]);\n              } else if (_m.length > 1) {\n                re = new RegExp(_m[1]);\n              }\n            } else {\n              re = key;\n            }\n\n            if (re && val) {\n              retval = retval.replace(re, val);\n            }\n          }\n        }\n      }\n\n      return retval;\n    }\n    /**\r\n     * Gets new Sunorhc instance with a UTC date from the local timezone date.\r\n     *\r\n     * @public\r\n     */\n\n  }, {\n    key: \"getUTC\",\n    value: function getUTC() {\n      if (this.config.timezone === 'UTC') {\n        // Clone if an origin instance is UTC\n        return this.clone();\n      } else {\n        // Make new if an origin instance is local timezone date\n        var newConfig = _utils__WEBPACK_IMPORTED_MODULE_0__.default.deepMerge({}, this.config);\n        newConfig.timezone = 'UTC';\n        newConfig.tzName = '';\n        var sysTzOffset = new Date().getTimezoneOffset() * MS_A_MINUTE;\n        var newPayloads = [this._i.$Y, this._i.$MON, this._i.$D, this._i.$H, this._i.$M, this._i.$S, this._i.$MS + sysTzOffset, newConfig];\n        return wrapper.apply(void 0, newPayloads);\n      }\n    }\n    /**\r\n     * Converts the current Sunorhc instance to a Date object with a UTC date.\r\n     *\r\n     * @public\r\n     */\n\n  }, {\n    key: \"toUTCDate\",\n    value: function toUTCDate() {\n      return this.config.timezone === 'UTC' ? this._baseDate : new Date(this._baseDate.getTime() + this._baseDate.getTimezoneOffset() * MS_A_MINUTE);\n    }\n    /**\r\n     * Gets new Sunorhc instance of the local timezoned date from the UTC date.\r\n     * Specification: `new Sunorhc().getZoned()` should be equal `new Sunorhc('local')`.\r\n     * If an instance date is already in the local timezone, the same instance will be duplicated.\r\n     * \r\n     * @public\r\n     */\n\n  }, {\n    key: \"getZoned\",\n    value: function getZoned() {\n      // Make new if an origin instance is UTC date\n      var newConfig = _utils__WEBPACK_IMPORTED_MODULE_0__.default.deepMerge({}, this.config);\n      newConfig.timezone = 'local';\n      newConfig.tzName = '';\n      var newPayloads = [this._i.$Y, this._i.$MON, this._i.$D, this._i.$H, this._i.$M, this._i.$S, this._i.$MS, newConfig];\n\n      if (this.config.timezone === 'UTC') {\n        // When to zoned date from UTC\n        newPayloads[6] = this._i.$MS - this._baseDate.getTimezoneOffset() * MS_A_MINUTE;\n      }\n\n      return wrapper.apply(void 0, newPayloads);\n    }\n    /**\r\n     * Converts the current Sunorhc instance to a Date object with a local timezoned date.\r\n     *\r\n     * @public\r\n     */\n\n  }, {\n    key: \"toZonedDate\",\n    value: function toZonedDate() {\n      if (this.config.timezone === 'local') {\n        return new Date(this._baseDate.getTime() + this._baseDate.getTimezoneOffset() * MS_A_MINUTE);\n      } else {\n        // from UTC date\n        var _dt = this._baseDate,\n            _y = _dt.getFullYear();\n\n        var _local = new Date(_y, _dt.getMonth(), _dt.getDate(), _dt.getHours(), _dt.getMinutes(), _dt.getSeconds(), _dt.getMilliseconds());\n\n        if (_y < 100) {\n          _local = new Date(_local.setFullYear(_y));\n        }\n\n        return _local;\n      }\n    }\n    /**\r\n     * Get the time difference from the UTC date in the timezone of the current system.\r\n     *\r\n     * @public\r\n     * @param {?string} unit [unit=ms] - `s` as second or `ms` as millisecond, `full` or `hhmm` etc.\r\n     */\n\n  }, {\n    key: \"getTZOffset\",\n    value: function getTZOffset() {\n      var unit = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'ms';\n\n      var _utcDt = this.toUTCDate(),\n          offsetMS = _utcDt.getTime() - this._baseDate.getTime();\n\n      switch (true) {\n        case /^h(|ours?)$/i.test(unit):\n          return Math.round(offsetMS / MS_A_HOUR * 100) / 100;\n\n        case /^min(|utes?)$/i.test(unit):\n          return Math.floor(offsetMS / MS_A_MINUTE);\n\n        case /^s(|(ec(|onds?)))$/i.test(unit):\n          return Math.floor(offsetMS / MS_A_SECOND);\n\n        case /^(full|hhmm)$/i.test(unit):\n          if (this.config.timezone !== 'UTC') {\n            var offsetH = Math.floor(Math.abs(offsetMS) / MS_A_HOUR),\n                offsetM = Math.floor((Math.abs(offsetMS) - offsetH * MS_A_HOUR) / MS_A_MINUTE),\n                offsetS = Math.floor((Math.abs(offsetMS) - (offsetH * MS_A_HOUR + offsetM * MS_A_MINUTE)) / MS_A_SECOND),\n                remainMS = Math.abs(offsetMS) - (offsetH * MS_A_HOUR + offsetM * MS_A_MINUTE + offsetS * MS_A_SECOND),\n                signStr = offsetMS <= 0 ? '+' : '-';\n            return /^full$/i.test(unit) ? \"\".concat(signStr).concat(offsetH.toString().padStart(2, '0'), \":\").concat(offsetM.toString().padStart(2, '0'), \":\").concat(offsetS.toString().padStart(2, '0'), \".\").concat(remainMS.toString().padStart(3, '0')) : \"\".concat(signStr).concat(offsetH.toString().padStart(2, '0'), \":\").concat(offsetM.toString().padStart(2, '0'));\n          } else {\n            return /^full$/i.test(unit) ? '+00:00:00.000' : '+00:00';\n          }\n\n        default:\n          return offsetMS;\n      }\n    }\n    /**\r\n     * Calculates the date added or subtracted by the specified unit to the instantiated date.\r\n     *\r\n     * @public\r\n     * @param {number} payload - Integer of the quantity to be increased or decreased; To decrease the value, specify a negative value\r\n     * @param {string} unit    - Unit of quantity specified as payload\r\n     */\n\n  }, {\n    key: \"modify\",\n    value: function modify(payload, unit) {\n      payload = parseInt(payload, 10);\n\n      if (isNaN(payload) || typeof unit !== 'string' || !REGEX_UNITS.test(unit)) {\n        return false;\n      }\n\n      var _bs = {\n        y: this._i.$Y,\n        m: this._i.$MON,\n        w: this._i.week,\n        d: this._i.$D,\n        h: this._i.$H,\n        mi: this._i.$M,\n        s: this._i.$S,\n        ms: this._i.$MS,\n        tz: this.config.timezone\n      };\n\n      var _modDt = null,\n          _tmp;\n\n      switch (true) {\n        case /^years?$/i.test(unit):\n          _modDt = wrapper(_bs.y + payload, _bs.m, _bs.d, _bs.h, _bs.mi, _bs.s, _bs.ms, _bs.tz);\n          break;\n\n        case /^months?$/i.test(unit):\n          _modDt = wrapper(_bs.y, _bs.m + payload, _bs.d, _bs.h, _bs.mi, _bs.s, _bs.ms, _bs.tz);\n          break;\n\n        case /^weeks?$/i.test(unit):\n          _tmp = _bs.d + payload * 7;\n\n          if (_tmp == 0) {\n            _modDt = wrapper(_bs.y, _bs.m, _bs.d, _bs.h - 24, _bs.mi, _bs.s, _bs.ms, _bs.tz);\n          } else {\n            _modDt = wrapper(_bs.y, _bs.m, _tmp, _bs.h, _bs.mi, _bs.s, _bs.ms, _bs.tz);\n          }\n\n          break;\n\n        case /^days?$/i.test(unit):\n          _tmp = _bs.d + payload;\n\n          if (_tmp == 0) {\n            _modDt = wrapper(_bs.y, _bs.m, _bs.d, _bs.h - 24, _bs.mi, _bs.s, _bs.ms, _bs.tz);\n          } else {\n            _modDt = wrapper(_bs.y, _bs.m, _tmp, _bs.h, _bs.mi, _bs.s, _bs.ms, _bs.tz);\n          }\n\n          break;\n\n        case /^h(|ours?)$/i.test(unit):\n          _modDt = wrapper(_bs.y, _bs.m, _bs.d, _bs.h + payload, _bs.mi, _bs.s, _bs.ms, _bs.tz);\n          break;\n\n        case /^min(|utes?)$/i.test(unit):\n          _modDt = wrapper(_bs.y, _bs.m, _bs.d, _bs.h, _bs.mi + payload, _bs.s, _bs.ms, _bs.tz);\n          break;\n\n        case /^sec(|onds?)$/i.test(unit):\n          _modDt = wrapper(_bs.y, _bs.m, _bs.d, _bs.h, _bs.mi, _bs.s + payload, _bs.ms, _bs.tz);\n          break;\n\n        case /^m(s|illiseconds?)$/i.test(unit):\n          _modDt = wrapper(_bs.y, _bs.m, _bs.d, _bs.h, _bs.mi, _bs.s, _bs.ms + payload, _bs.tz);\n          break;\n      }\n\n      return _modDt.isValid() ? _modDt : INVALID_DATE;\n    }\n    /**\r\n     * Alias as shorthand of \"modify\" method.\r\n     *\r\n     * @public\r\n     */\n\n  }, {\n    key: \"mod\",\n    value: function mod(payload, unit) {\n      return this.modify(payload, unit);\n    }\n    /**\r\n     * Get calculated interval between the instantiated date and a specific date, with the \r\n     * specified unit.\r\n     *\r\n     * @public\r\n     * @param {string} compare\r\n     * @param {?string} unit\r\n     */\n\n  }, {\n    key: \"interval\",\n    value: function interval(compare) {\n      var unit = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n      var compareObj = wrapper(compare);\n\n      if (!compare || compareObj === INVALID_DATE || !compareObj.isValid()) {\n        return false;\n      }\n\n      var diffMs = compareObj.instant.$UMS - this._i.$UMS,\n          diffDays = Math.ceil(diffMs / MS_A_DAY);\n\n      switch (true) {\n        case /^years?$/i.test(unit):\n          if (Math.abs(diffDays) < MIN_YEAR_DAYS) {\n            return 0;\n          } else if (Math.abs(diffDays) > AVG_YEAR_DAYS) {\n            return Math.ceil(diffDays / AVG_YEAR_DAYS * 10) / 10;\n          } else {\n            return 1;\n          }\n\n        case /^months?$/i.test(unit):\n          if (Math.abs(diffDays) < MIN_MONTH_DAYS) {\n            return 0;\n          } else if (Math.abs(diffDays) > AVG_MONTH_DAYS) {\n            return Math.ceil(diffDays / AVG_MONTH_DAYS * 10) / 10;\n          } else {\n            return 1;\n          }\n\n        case /^weeks?$/i.test(unit):\n          return Math.ceil(diffMs / MS_A_WEEK * 10) / 10;\n\n        case /^days?$/i.test(unit):\n          return Math.ceil(diffMs / MS_A_DAY);\n\n        case /^hours?$/i.test(unit):\n          return Math.ceil(diffMs / MS_A_HOUR);\n\n        case /^min(|utes?)$/i.test(unit):\n          return Math.ceil(diffMs / MS_A_MINUTE);\n\n        case /^sec(|onds?)$/i.test(unit):\n          return Math.ceil(diffMs / MS_A_SECOND);\n\n        case /^m(s|illiseconds?)$/i.test(unit):\n        default:\n          if (Number.MAX_SAFE_INTEGER < diffMs) {\n            diffMs = BI(diffMs);\n          }\n\n          return diffMs;\n      }\n    }\n    /**\r\n     * Duplicate an instance of a Sunorhc object.\r\n     *\r\n     * @public\r\n     */\n\n  }, {\n    key: \"clone\",\n    value: function clone() {\n      var datePayloads = [this._i.$Y, this._i.$MON, this._i.$D, this._i.$H, this._i.$M, this._i.$S, this._i.$MS, _utils__WEBPACK_IMPORTED_MODULE_0__.default.deepMerge({}, this.config)];\n      return wrapper.apply(void 0, datePayloads);\n    }\n    /**\r\n     * Determines if the Date object given in the argument is valid.\r\n     * Evaluates the instance's own date if there are no arguments or if the argument is not \r\n     * a date object.\r\n     *\r\n     * @public\r\n     * @param {?any} date \r\n     */\n\n  }, {\n    key: \"isValid\",\n    value: function isValid() {\n      var date = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n      var chkDate = date ? date instanceof Date ? date : new Date(date) : this._baseDate;\n      return !(chkDate.toString() === INVALID_DATE);\n    }\n    /**\r\n     * The week number for the year is calculated.\r\n     *\r\n     * @public\r\n     */\n\n  }, {\n    key: \"getWeekOfYear\",\n    value: function getWeekOfYear() {\n      var _isUTC = this.config.timezone === 'UTC',\n          _y = _utils__WEBPACK_IMPORTED_MODULE_0__.default.hasKey(this, '_i') ? this._i.$Y : _isUTC ? this._baseDate.getUTCFullYear() : this._baseDate.getFullYear();\n\n      var firstDayOfYear = _isUTC ? new Date(Date.UTC(_y, 0, 1)) : new Date(_y, 0, 1);\n\n      if (_y < 100) {\n        firstDayOfYear = _isUTC ? new Date(firstDayOfYear.setUTCFullYear(_y)) : new Date(firstDayOfYear.setFullYear(_y));\n      }\n\n      var dayOfYear = (this._baseDate.getTime() - firstDayOfYear.getTime() + MS_A_DAY) / MS_A_DAY;\n      return Math.ceil(dayOfYear / 7);\n    }\n    /**\r\n     * The total number of days in the year on the instantiated date is calculated.\r\n     *\r\n     * @public\r\n     */\n\n  }, {\n    key: \"getDaysInYear\",\n    value: function getDaysInYear() {\n      var _y = this.config.timezone === 'UTC' ? this._baseDate.getUTCFullYear() : this.toZonedDate().getFullYear(),\n          isLeapYear = _y % 4 == 0;\n\n      return isLeapYear ? 366 : 365;\n    }\n    /**\r\n     * The total number of days in the month on the instantiated date is calculated.\r\n     *\r\n     * @public\r\n     */\n\n  }, {\n    key: \"getDaysInMonth\",\n    value: function getDaysInMonth() {\n      var _y = this.config.timezone === 'UTC' ? this._baseDate.getUTCFullYear() : this.toUTCDate().getUTCFullYear(),\n          _m = this.config.timezone === 'UTC' ? this._baseDate.getUTCMonth() : this.toUTCDate().getUTCMonth();\n\n      var _nmDt = new Date(Date.UTC(_y, _m + 1, 1, 0, 0, 0, 0)),\n          _lmDt,\n          lastDay;\n\n      if (_y < 100) {\n        _nmDt = new Date(_nmDt.setUTCFullYear(_y));\n      }\n\n      _lmDt = new Date(_nmDt.getTime() - 1);\n      lastDay = _lmDt.getUTCDate();\n      return lastDay;\n    }\n    /**\r\n     * Get cumulative days in year untill current day from first day of year.\r\n     *\r\n     * @public\r\n     */\n\n  }, {\n    key: \"getCumulativeDays\",\n    value: function getCumulativeDays() {\n      var _y = this._baseDate.getUTCFullYear();\n\n      var _fDt = new Date(Date.UTC(_y, 0, 1, 0, 0, 0, 0)),\n          _mtime = _utils__WEBPACK_IMPORTED_MODULE_0__.default.hasKey(this, '_i') ? this._i.$UMS : this.getUnixTime('ms');\n\n      if (_y < 100) {\n        _fDt = new Date(_fDt.setUTCFullYear(_y));\n      }\n\n      if (this.config.timezone === 'local') {\n        _mtime -= this.config.offset;\n      }\n\n      return Math.abs(Math.floor((_mtime - _fDt.getTime()) / MS_A_DAY));\n    }\n    /**\r\n     * Get the numeric index of weekday depended on specified format.\r\n     *\r\n     * @public\r\n     * @param {?string} format - \"iso8601\" or that else can be specified; otherwise, no argument is specified\r\n     */\n\n  }, {\n    key: \"getWeekdayIndex\",\n    value: function getWeekdayIndex() {\n      var format = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n\n      if (/^iso8601$/i.test(format)) {\n        // ISO-8601 format numeric weekday: 1 (Monday) - 7 (Sunday)\n        return [7, 1, 2, 3, 4, 5, 6][this.config.timezone === 'UTC' ? this._baseDate.getUTCDay() : this.toUTCDate().getDay()];\n      } else {\n        // numeric weekday: 0 (Sunday) - 6 (Saturday)\n        return this.config.timezone === 'UTC' ? this._baseDate.getUTCDay() : this.toUTCDate().getDay();\n      }\n    }\n    /**\r\n     * Get the ISO 8601 string of date and time depended on specified format.\r\n     * Note: If the instance datetime is local time, it will be formatted as UTC datetime.\r\n     *\r\n     * @public\r\n     * @param {?string} format [format=full] - \"date\", \"week\", \"weekday\", \"ordinal\", \"time\", \"offset\", \"noz\" or \"full\".\r\n     */\n\n  }, {\n    key: \"getISO\",\n    value: function getISO() {\n      var format = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"full\";\n      var _i = this._i,\n          _dtP = {\n        y: Math.abs(_i.$Y) < 1000 ? (_i.$Y < 0 ? '-' : '') + Math.abs(_i.$Y).toString().padStart(4, '0') : _i.$Y.toString(),\n        m: _i.$MON.toString().padStart(2, '0'),\n        d: _i.$D.toString().padStart(2, '0'),\n        w: \"W\".concat(_i.$W.toString().padStart(2, '0')),\n        wd: _i.$WD,\n        o: this.getCumulativeDays(),\n        h: _i.$H.toString().padStart(2, '0'),\n        mi: _i.$M.toString().padStart(2, '0'),\n        s: _i.$S.toString().padStart(2, '0'),\n        ms: _i.$MS.toString().padStart(3, '0'),\n        of: _i.$TZOL\n      };\n\n      switch (true) {\n        case /^date$/i.test(format):\n          return \"\".concat(_dtP.y, \"-\").concat(_dtP.m, \"-\").concat(_dtP.d);\n\n        case /^week$/i.test(format):\n          return \"\".concat(_dtP.y, \"-\").concat(_dtP.w);\n\n        case /^weekday$/i.test(format):\n          return \"\".concat(_dtP.y, \"-\").concat(_dtP.w, \"-\").concat(_dtP.wd);\n\n        case /^ordinal$/i.test(format):\n          return \"\".concat(_dtP.y, \"-\").concat(_dtP.o);\n\n        case /^time$/i.test(format):\n          return \"\".concat(_dtP.h, \":\").concat(_dtP.mi, \":\").concat(_dtP.s, \".\").concat(_dtP.ms);\n\n        case /^offset$/i.test(format):\n          return _dtP.of;\n\n        case /^noz$/i.test(format):\n          // The offset in \"HH:mm\" format is given instead of the suffix \"Z\" in the UTC time zone.\n          return \"\".concat(_dtP.y, \"-\").concat(_dtP.m, \"-\").concat(_dtP.d, \"T\").concat(_dtP.h, \":\").concat(_dtP.mi, \":\").concat(_dtP.s, \".\").concat(_dtP.ms).concat(_dtP.of);\n\n        default:\n          if (this.config.timezone === 'UTC') {\n            _dtP.of = 'Z';\n          }\n\n          return \"\".concat(_dtP.y, \"-\").concat(_dtP.m, \"-\").concat(_dtP.d, \"T\").concat(_dtP.h, \":\").concat(_dtP.mi, \":\").concat(_dtP.s, \".\").concat(_dtP.ms).concat(_dtP.of);\n      }\n    }\n    /**\r\n     * Get the RFC xxxx string as legacy date and time format.\r\n     * We no longer recommend the use of this format.\r\n     *\r\n     * @public\r\n     * @param {?number} format - enabled format is 2822, 3339\r\n     */\n\n  }, {\n    key: \"getRFC\",\n    value: function getRFC() {\n      var format = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n\n      var _origin = this._baseDate.toString(),\n          _i = this._i,\n          _year = Math.abs(_i.$Y) < 1000 ? (_i.$Y < 0 ? '-' : '') + Math.abs(_i.$Y).toString().padStart(4, '0') : _i.$Y,\n          _month = _i.$MON.toString().padStart(2, '0'),\n          _day = _i.$D.toString().padStart(2, '0'),\n          _hour = _i.$H.toString().padStart(2, '0'),\n          _minute = _i.$M.toString().padStart(2, '0'),\n          _second = _i.$S.toString().padStart(2, '0'),\n          _offset = _i.$TZOL.replace(':', ''),\n          _parsed = _origin.split(/\\s*\\(/).pop().replace(')', '') || null;\n\n      switch (true) {\n        case /^2822$/.test(format):\n          _offset = _i.$TZO == 0 && !this.hasDST() ? 'GMT' : _offset;\n          return \"\".concat(_i.$WDS, \", \").concat(_day, \" \").concat(_i.$MONS, \" \").concat(_year, \" \").concat(_hour, \":\").concat(_minute, \":\").concat(_second, \" \").concat(_offset);\n\n        case /^3339$/i.test(format):\n          return \"\".concat(_year, \"-\").concat(_month, \"-\").concat(_day, \"T\").concat(_hour, \":\").concat(_minute, \":\").concat(_second).concat(_offset);\n\n        default:\n          _offset = \"GMT\".concat(_offset);\n\n          if (_parsed) {\n            _offset += this.config.timezone === 'UTC' ? \" (UTC)\" : \" (\".concat(_parsed, \")\");\n          }\n\n          return \"\".concat(_i.$WDS, \" \").concat(_i.$MONS, \" \").concat(_day, \" \").concat(_year, \" \").concat(_hour, \":\").concat(_minute, \":\").concat(_second, \" \").concat(_offset);\n      }\n    }\n    /**\r\n     * Whether or not the timezone to which the instance's primitive datatime belongs observes DST.\r\n     *\r\n     * @public\r\n     */\n\n  }, {\n    key: \"hasDST\",\n    value: function hasDST() {\n      if (this.config.timezone === 'UTC') {\n        return false;\n      }\n\n      if (!_utils__WEBPACK_IMPORTED_MODULE_0__.default.hasKey(this, '_cacheDST')) {\n        var fy = this._baseDate.getFullYear();\n\n        var _dt = new Date(fy, 0, 1);\n\n        if (fy < 100) {\n          _dt = new Date(_dt.setFullYear(fy));\n        }\n\n        this._cacheDST = [_dt.getTimezoneOffset()];\n\n        for (var mi = 1; mi < 12; mi++) {\n          var _tmp = new Date(fy, mi, 1);\n\n          if (fy < 100) {\n            _tmp = new Date(_tmp.setFullYear(fy));\n          }\n\n          this._cacheDST.push(_tmp.getTimezoneOffset());\n        }\n      }\n\n      return Math.min.apply(Math, _toConsumableArray(this._cacheDST)) < Math.max.apply(Math, _toConsumableArray(this._cacheDST));\n    }\n    /**\r\n     * Whether the primitive datetime of the instance is during DST or not.\r\n     *\r\n     * @public\r\n     */\n\n  }, {\n    key: \"isDST\",\n    value: function isDST() {\n      if (!this.hasDST()) {\n        return false;\n      }\n\n      return this._baseDate.getTimezoneOffset() == Math.min.apply(Math, _toConsumableArray(this._cacheDST));\n    }\n    /**\r\n     * Get the time difference when the instance's timezone observes DST.\r\n     * Returns the relative value of the time difference between local time and DST.\r\n     *\r\n     * @public\r\n     * @param {?string} unit [unit=ms] - allowed units are \"hour\", \"minute\", \"second\" or \"millisecond\".\r\n     */\n\n  }, {\n    key: \"getDSTOffset\",\n    value: function getDSTOffset() {\n      var unit = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'ms';\n\n      if (!this.isDST()) {\n        return 0;\n      }\n\n      var offsetMS = Math.min.apply(Math, _toConsumableArray(this._cacheDST)) * MS_A_MINUTE - Math.max.apply(Math, _toConsumableArray(this._cacheDST)) * MS_A_MINUTE;\n\n      switch (true) {\n        case /^h(|ours)?$/i.test(unit):\n          return offsetMS / MS_A_HOUR;\n\n        case /^min(|utes?)$/i.test(unit):\n          return offsetMS / MS_A_MINUTE;\n\n        case /^s(|(ec(|onds?)))$/i.test(unit):\n          return offsetMS / MS_A_SECOND;\n\n        case /^(ms|milliseconds?)$/i.test(unit):\n        default:\n          return offsetMS;\n      }\n    }\n    /**\r\n     * Getters\r\n     *\r\n     * @public\r\n     */\n\n  }, {\n    key: \"version\",\n    get: function get() {\n      return \"v\".concat(this.config.version);\n    }\n  }, {\n    key: \"instant\",\n    get: function get() {\n      return Object.assign({}, this._i);\n    }\n  }, {\n    key: \"toDate\",\n    get: function get() {\n      return this._baseDate;\n    }\n  }, {\n    key: \"toString\",\n    get: function get() {\n      return this.getRFC();\n    }\n  }, {\n    key: \"toISOString\",\n    get: function get() {\n      return this.getISO();\n    }\n  }, {\n    key: \"year\",\n    get: function get() {\n      return this._i.$Y;\n    }\n  }, {\n    key: \"month\",\n    get: function get() {\n      return this._i.$MON;\n    }\n  }, {\n    key: \"monthLong\",\n    get: function get() {\n      return this._i.$MONL;\n    }\n  }, {\n    key: \"monthShort\",\n    get: function get() {\n      return this._i.$MONS;\n    }\n  }, {\n    key: \"week\",\n    get: function get() {\n      return this._i.$W;\n    }\n  }, {\n    key: \"day\",\n    get: function get() {\n      return this._i.$D;\n    }\n  }, {\n    key: \"weekday\",\n    get: function get() {\n      return this._i.$WD;\n    }\n  }, {\n    key: \"weekdayLong\",\n    get: function get() {\n      return this._i.$WDL;\n    }\n  }, {\n    key: \"weekdayShort\",\n    get: function get() {\n      return this._i.$WDS;\n    }\n  }, {\n    key: \"ordinalDays\",\n    get: function get() {\n      return this._i.$O;\n    }\n  }, {\n    key: \"hour\",\n    get: function get() {\n      return this._i.$H;\n    }\n  }, {\n    key: \"minute\",\n    get: function get() {\n      return this._i.$M;\n    }\n  }, {\n    key: \"second\",\n    get: function get() {\n      return this._i.$S;\n    }\n  }, {\n    key: \"millisecond\",\n    get: function get() {\n      return this._i.$MS;\n    }\n  }, {\n    key: \"timezone\",\n    get: function get() {\n      return _utils__WEBPACK_IMPORTED_MODULE_0__.default.hasKey(this.config, 'tzName') && this.config.tzName !== '' ? this.config.tzName : this._i.$TZ;\n    }\n  }, {\n    key: \"tzOffset\",\n    get: function get() {\n      return this._i.$TZO;\n    }\n  }, {\n    key: \"tzOffsetHM\",\n    get: function get() {\n      return this._i.$TZOL;\n    }\n  }, {\n    key: \"tzOffsetFull\",\n    get: function get() {\n      return this._i.$TZOF;\n    }\n  }, {\n    key: \"era\",\n    get: function get() {\n      return this._i.$E;\n    }\n  }, {\n    key: \"unix\",\n    get: function get() {\n      return /^(ms|milliseconds?)$/i.test(this.config.epochUnit) ? this._i.$UMS : this._i.$U;\n    }\n  }, {\n    key: \"ce\",\n    get: function get() {\n      return /^(ms|milliseconds?)$/i.test(this.config.epochUnit) ? this._i.$CEMS : this._i.$CE;\n    }\n  }]);\n\n  return Sunorhc;\n}();\n\n\n\n//# sourceURL=webpack://Sunorhc/./src/index.js?");

/***/ }),

/***/ "./src/utils.js":
/*!**********************!*\
  !*** ./src/utils.js ***!
  \**********************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval("__webpack_require__.r(__webpack_exports__);\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }\n\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _iterableToArray(iter) { if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter); }\n\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }\n\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\n\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== \"undefined\" && arr[Symbol.iterator] || arr[\"@@iterator\"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nvar strInsert = function strInsert(str, idx, val) {\n  return str.slice(0, idx) + val + str.slice(idx);\n};\n\nvar strRemove = function strRemove(str, idx) {\n  var len = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n  return str.slice(0, idx) + str.slice(idx + len);\n};\n\nvar isObject = function isObject(one) {\n  return !!one && _typeof(one) === 'object' && !Array.isArray(one);\n};\n\nvar hasKey = function hasKey(obj, key) {\n  return !!obj && Object.prototype.hasOwnProperty.call(obj, key);\n};\n\nvar cloneObject = function cloneObject(obj) {\n  return JSON.parse(JSON.stringify(obj));\n};\n\nvar deepMerge = function deepMerge(target, source, opts) {\n  var isConcatArray = opts && opts.concatArray;\n  var result = Object.assign({}, target);\n\n  if (isObject(target) && isObject(source)) {\n    for (var _i = 0, _Object$entries = Object.entries(source); _i < _Object$entries.length; _i++) {\n      var _Object$entries$_i = _slicedToArray(_Object$entries[_i], 2),\n          srcKey = _Object$entries$_i[0],\n          srcVal = _Object$entries$_i[1];\n\n      var targetVal = target[srcKey];\n\n      if (isConcatArray && Array.isArray(srcVal) && Array.isArray(targetVal)) {\n        result[srcKey] = targetVal.concat.apply(targetVal, _toConsumableArray(srcVal));\n      } else if (isObject(srcVal) && hasKey(target, srcKey)) {\n        result[srcKey] = deepMerge(targetVal, srcVal, opts);\n      } else {\n        Object.assign(result, _defineProperty({}, srcKey, srcVal));\n      }\n    }\n  }\n\n  return cloneObject(result);\n};\n\nvar mergeOptions = function mergeOptions(defaults, settings) {\n  var finalOpts = deepMerge({}, defaults);\n\n  if (isObject(defaults) && isObject(settings)) {\n    for (var _i2 = 0, _Object$entries2 = Object.entries(settings); _i2 < _Object$entries2.length; _i2++) {\n      var _Object$entries2$_i = _slicedToArray(_Object$entries2[_i2], 2),\n          setKey = _Object$entries2$_i[0],\n          setVal = _Object$entries2$_i[1];\n\n      var allowKeys = Object.keys(defaults).concat('dateArgs', 'offset', 'tzName');\n\n      if (allowKeys.includes(setKey)) {\n        var defVal = finalOpts[setKey],\n            vType = _typeof(setVal);\n\n        switch (setKey) {\n          case 'timezone':\n            if (vType === 'string') {\n              finalOpts[setKey] = /^(UTC)$/i.test(setVal) ? 'UTC' : 'local';\n\n              if (!/^(UTC|local)$/i.test(setVal)) {\n                finalOpts.tzName = setVal;\n              }\n            }\n\n            break;\n\n          case 'firstArgument':\n            if (vType === 'string' && /^(ce(|epoch)|timestamp|unix|year)$/i.test(setVal)) {\n              finalOpts[setKey] = setVal.toLowerCase();\n            }\n\n            break;\n\n          case 'locale':\n            if (vType === 'string') {\n              var _locale = new Intl.Locale(setVal);\n\n              finalOpts[setKey] = _locale.baseName;\n            }\n\n            break;\n\n          case 'epochUnit':\n            if (vType === 'string' && /^(sec|seconds?|ms|milliseconds?)$/i.test(setVal)) {\n              finalOpts[setKey] = setVal.toLowerCase();\n            }\n\n            break;\n\n          case 'localeFormats':\n            if (isObject(setVal)) {\n              var defKeys = Object.keys(defVal);\n\n              for (var _i3 = 0, _Object$entries3 = Object.entries(setVal); _i3 < _Object$entries3.length; _i3++) {\n                var _Object$entries3$_i = _slicedToArray(_Object$entries3[_i3], 2),\n                    lfKey = _Object$entries3$_i[0],\n                    lfVal = _Object$entries3$_i[1];\n\n                if (defKeys.includes(lfKey)) {\n                  if (isObject(lfVal)) {\n                    finalOpts.localeFormats[lfKey] = deepMerge(defVal[lfKey], lfVal);\n                  } else if (typeof lfVal === 'string' && lfKey !== 'common') {\n                    finalOpts.localeFormats[lfKey] = _defineProperty({}, lfKey, lfVal);\n                  }\n                }\n              }\n            }\n\n            break;\n\n          case 'verbose':\n            if (vType === 'boolean') {\n              finalOpts[setKey] = setVal;\n            }\n\n            break;\n\n          default:\n            // Cannot be overwritten\n            break;\n        }\n      }\n    }\n  }\n\n  return finalOpts;\n};\n\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\n  strInsert: strInsert,\n  strRemove: strRemove,\n  isObject: isObject,\n  hasKey: hasKey,\n  cloneObject: cloneObject,\n  deepMerge: deepMerge,\n  mergeOptions: mergeOptions\n});\n\n//# sourceURL=webpack://Sunorhc/./src/utils.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	!function() {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = function(exports, definition) {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	!function() {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	!function() {
/******/ 		__webpack_require__.o = function(obj, prop) { return Object.prototype.hasOwnProperty.call(obj, prop); }
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	!function() {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = function(exports) {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	}();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/index.js");
/******/ 	__webpack_exports__ = __webpack_exports__.default;
/******/ 	
/******/ 	return __webpack_exports__;
/******/ })()
;
});